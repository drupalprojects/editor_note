<?php

/**
 * @file
 * Main functionality for Notes Field module.
 */

/**
 * @todo field doesn't cleans up when removing field from bundle. Test how default fields work in that case. Special conformation form should be added, its submit callback will remove the data.
 * @todo make cardinality hidden and 1 by default (because element with delta > 0 is not used at all), implement alternative setting.
 *  There can be problems with editor_note_theme_field_multiple_value_form in this case. @see https://api.drupal.org/api/drupal/modules%21field%21field.api.php/function/hook_field_widget_info/7
 * @todo think about CRUD permissions on editor note entity, check field permissions - https://www.drupal.org/project/field_permissions
 * @todo how to distinguish 2 pagers on the page, 2 pagers - if one field should have pager and another should not - pagers anyway show up
 *
 * @todo add wysiwyg/filtered text support in the future, add 'format' column
 * @todo add detailed README.txt and hook_help
 * @todo if .module file is too large break it down into several smaller files.
 *
 * @todo implement hooks and think about .api.php file.
 */

/**
 * Implements hook_help().
 */
/**
 * Implements hook_help().
 */
function editor_note_help($path, $arg) {
  if ($path == 'admin/help#editor_note') {
    $readme_path = drupal_get_path('module', 'editor_note') . '/README.txt';
    $readme_request = drupal_http_request(url($readme_path, array('absolute' => TRUE)));
    if (isset($readme_request->data) && !isset($readme_request->error)) {
      // Returns a line-break version of the module README.txt.
      return _filter_autop($readme_request->data);
    }
  }
}

/**
 * Implements hook_menu().
 */
function editor_note_menu() {
  $items['editor_note/edit/%ctools_js/%'] = array(
    'title' => 'Update Note',
    'page arguments' => array(2, 3),
    'page callback' => 'editor_note_confirm_edit_page',
    'access callback' => 'editor_note_access_crud_operations',
    'access arguments' => array(3),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['editor_note/remove/%ctools_js/%'] = array(
    'title' => 'Remove Note',
    'page arguments' => array(2, 3),
    'page callback' => 'editor_note_confirm_remove_page',
    'access callback' => 'editor_note_access_crud_operations',
    'access arguments' => array(3),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function editor_note_permission() {
  return array(
    'administer any editor note' => array(
      'title' => t('Administer any editor note'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function editor_note_theme() {
  return array(
    'editor_note_message' => array(
      'variables' => array(
        'field_name' => NULL,
        'message_text' => NULL,
        'message_type' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function editor_note_entity_info() {
  $entity = array(
    'editor_note' => array(
      'label' => t('Editor Note'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'views controller class' => 'EntityDefaultViewsController',
      'base table' => 'editor_note',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
      ),
      'module' => 'editor_note',
    ),
  );

  return $entity;
}

/**
 * Implements hook_entity_property_info().
 */
function editor_note_entity_property_info() {
  $properties = array(
    'id' => array(
      'type'  => 'integer',
      'label' => t('Editor Note ID'),
      'description' => t('Unique editor note ID.'),
      'schema field' => 'id',
    ),
    'note' => array(
      'type'  => 'text',
      'label' => t('Editor Note'),
      'description' => t('Content of editor note.'),
      'schema field' => 'note',
    ),
    'entity_type' => array(
      'type' => 'text',
      'label' => t('Entity Type'),
      'description' => 'The entity type editor note is attached to.',
      'schema field' => 'entity_type',
    ),
    'bundle' => array(
      'type' => 'text',
      'label' => t('Bundle'),
      'description' => 'The bundle of the entity editor note is attached to.',
      'schema field' => 'bundle',
    ),
    'field_name' => array(
      'type' => 'text',
      'label' => t('Field Name'),
      'description' => 'The field name of the field containing editor note.',
      'schema field' => 'field_name',
    ),
    'entity_id' => array(
      'type' => 'integer',
      'label' => t('Entity ID'),
      'description' => 'The entity id editor note is attached to.',
      'schema field' => 'entity_id',
    ),
    'revision_id' => array(
      'type' => 'integer',
      'label' => t('Revision ID'),
      'description' => 'The entity revision editor note is attached to.',
      'schema field' => 'revision_id',
    ),
    'uid' => array(
      'type'  => 'integer',
      'label' => t('Updated by UID'),
      'description' => t('The unique ID of the user who last updated editor note.'),
      'schema field' => 'uid',
    ),
    'created' => array(
      'type' => 'date',
      'label' => t('Created'),
      'description' => 'The timestamp that the note was created.',
      'schema field' => 'created',
    ),
    'changed' => array(
      'type' => 'date',
      'label' => t('Changed'),
      'description' => 'The timestamp that the note was last updated.',
      'schema field' => 'changed',
    ),
  );

  $info['editor_note']['properties'] = $properties;

  return $info;
}


/**
 * Implements hook_views_data_alter().
 */
function editor_note_views_data_alter(&$data) {
  // Exposes uid as a relationship to users.
  $data['editor_note']['author_info'] = array(
    'title' => t('User information.'),
    'help' => t('Information related to user who authored/updated the note.'),
    'relationship' => array(
      'base' => 'users',
      'base field' => 'uid',
      'relationship field' => 'uid',
      'handler' => 'views_handler_relationship',
      'label' => t('User information.'),
    ),
  );

  // Expose entity_id as a relationship to node (the most common use case).
  $data['editor_note']['node_info'] = array(
    'title' => t('Node information.'),
    'help' => t('Related node object.'),
    'relationship' => array(
      'base' => 'node',
      'base field' => 'nid',
      'relationship field' => 'entity_id',
      'handler' => 'views_handler_relationship',
      'label' => t('Node information.'),
    ),
  );
}

/**
 * Implements hook_entity_delete().
 */
function editor_note_entity_delete($entity, $type) {
  list($entity_id) = entity_extract_ids($type, $entity);
  // Removes notes from editor notes table.
  db_delete('editor_note')
    ->condition('entity_type', $type)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements hook_node_revision_delete().
 */
function editor_note_node_revision_delete($node) {
  // Removes notes from editor notes table.
  db_delete('editor_note')
    ->condition('entity_type', 'node')
    ->condition('entity_id', $node->nid)
    ->condition('revision_id', $node->vid)
    ->execute();
}

/**
 * Implements hook_field_delete().
 */
function editor_note_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  $ids = entity_extract_ids($entity_type, $entity);
  $bundle = $ids[2];
  // Removes notes from editor notes table.
  db_delete('editor_note')
    ->condition('entity_type', $entity_type)
    ->condition('bundle', $bundle)
    ->condition('field_name', $field['field_name'])
    ->execute();
}

/**
 * Implements hook_field_info().
 */
function editor_note_field_info() {
  return array(
    'editor_note' => array(
      'label' => t('Editor Notes'),
      'description' => t('Field for taking editor notes.'),
      'settings' => array(
        'notes_size' => 5,
        'notes_placeholder' => 'Create a note',
        'notes_maxlength' => 0,
        'limit' => 10,
        'order' => 'DESC',
        'display' => 1,
        'pager' => array(
          'enabled' => 1,
          'pager_below' => 1,
        ),
        'modal' => array(
          'overlay' => array(
            'opacity' => 0.7,
            'bgcolor' => '000000',
          ),
          'edit' => array(
            'width' => 600,
            'height' => 'auto',
          ),
          'remove' => array(
            'width' => 320,
            'height' => 'auto',
          ),
        ),
      ),
      'instance_settings' => array(),
      'default_widget' => 'editor_note_field_widget',
      'default_formatter' => 'editor_note_field_formatter',
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 *
 * Defines whether to save field value to the database.
 */
function editor_note_field_is_empty($item, $field) {
  if ($field['type'] == 'editor_note') {
    return empty($item['note']);
  }
}

/**
 * Implements hook_field_settings_form().
 *
 * Creates field settings form.
 */
function editor_note_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];

  $form['notes_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size of Notes field (rows)'),
    '#default_value' => $settings['notes_size'],
    '#required' => TRUE,
    '#description' => t('Specify the visible number of lines in textarea for adding note.'),
    '#element_validate' => array('element_validate_integer_positive'),
  );

  $form['notes_placeholder'] = array(
    '#type' => 'textfield',
    '#title' => t('Placeholder for blank Notes field'),
    '#default_value' => t($settings['notes_placeholder']),
    '#required' => FALSE,
    '#description' => t('Specifies a short hint that describes the expected value of the textarea.'),
  );

  $form['notes_maxlength'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of characters user can enter'),
    '#default_value' => $settings['notes_maxlength'],
    '#required' => TRUE,
    '#description' => t('Specifies the maximum number of characters allowed in the textarea. Set 0 for no limit.'),
    '#element_validate' => array('editor_note_validate_integer_positive_or_zero'),
  );

  $form['limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Display a specified number of items.'),
    '#default_value' => $settings['limit'],
    '#required' => TRUE,
    '#description' => t('Display a specified number of items. Set 0 for no limit.
    Keep in mind that "Number of values" field has more priority here.'),
    '#element_validate' => array('editor_note_validate_integer_positive_or_zero'),
  );

  $form['order'] = array(
    '#type' => 'radios',
    '#title' => t('Notes Ordering'),
    '#options' => array(
      'DESC' => t('display recently updated notes first'),
      'ASC' => t('display recently updated notes last'),
    ),
    '#default_value' => $settings['order'],
    '#description' => t('Set order of notes in the table.'),
  );

  $form['display'] = array(
    '#type' => 'checkbox',
    '#title' => t('Textarea above notes table'),
    '#default_value' => $settings['display'],
    '#description' => t('Display "Create a note" field above the notes table. Otherwise it will be shown below the notes table.'),
  );

  $form['pager'] = array(
    '#type' => 'fieldset',
    '#title' => t('Pagination'),
    '#collapsed' => FALSE,
    '#collapsible' => FALSE,
    '#states' => array(
      'invisible' => array(
        'input[name="field[settings][limit]"]' => array('value' => 0),
      ),
    ),
  );

  $form['pager']['enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable pagination'),
    '#default_value' => $settings['pager']['enabled'],
    '#description' => t('Whether to display pagination if number of notes added is greater that can be displayed.'),
  );

  $form['pager']['pager_below'] = array(
    '#type' => 'checkbox',
    '#title' => t('Pagination below notes table'),
    '#default_value' => $settings['pager']['pager_below'],
    '#description' => t('Displays pagination below the notes table, if unchecked pagination displays above the table.'),
    '#states' => array(
      'invisible' => array(
        'input[name="field[settings][pager][enabled]"]' => array('checked' => FALSE),
      ),
    ),
  );

  $form['modal'] = array(
    '#type' => 'fieldset',
    '#title' => t('Configuration of modal popups'),
    '#collapsed' => FALSE,
    '#collapsible' => FALSE,
  );

  $form['modal']['overlay'] = array(
    '#type' => 'fieldset',
    '#title' => t('Overlay'),
    '#collapsed' => FALSE,
    '#collapsible' => FALSE,
  );

  $form['modal']['overlay']['opacity'] = array(
    '#type' => 'textfield',
    '#title' => t('Opacity'),
    '#default_value' => $settings['modal']['overlay']['opacity'],
    '#maxlength' => 3,
    '#required' => TRUE,
    '#element_validate' => array('editor_note_validate_float_positive_or_zero'),
    '#description' => t('Sets opacity level for overlay. The opacity-level describes the transparency-level, where 1
    is not transparent at all, 0.6 - 0.4 is nearly 50% see-through, and 0 is completely transparent.'),
  );

  $form['modal']['overlay']['bgcolor'] = array(
    '#type' => 'textfield',
    '#title' => t('Background Color'),
    '#default_value' => $settings['modal']['overlay']['bgcolor'],
    '#element_validate' => array('editor_note_validate_hex'),
    '#maxlength' => 6,
    '#required' => TRUE,
    '#description' => t('Sets the background-color of overlay. Supports 6-digits HEX value. Do not include # sign. Example: 000000.'),
  );

  $form['modal']['edit'] = array(
    '#type' => 'fieldset',
    '#title' => t('"Edit" popup'),
    '#collapsed' => FALSE,
    '#collapsible' => FALSE,
  );

  $form['modal']['edit']['width'] = array(
    '#type' => 'textfield',
    '#title' => t('Width'),
    '#default_value' => $settings['modal']['edit']['width'],
    '#element_validate' => array('editor_note_validate_size'),
    '#required' => TRUE,
    '#description' => t('Sets the width of an "Edit" popup. Accepts either numeric value (pixels) or "auto" (the browser calculates the width).'),
  );

  $form['modal']['edit']['height'] = array(
    '#type' => 'textfield',
    '#title' => t('Height'),
    '#default_value' => $settings['modal']['edit']['height'],
    '#element_validate' => array('editor_note_validate_size'),
    '#required' => TRUE,
    '#description' => t('Sets the height of an "Edit" popup. Accepts either numeric value (pixels) or "auto" (the browser calculates the height).'),
  );

  $form['modal']['remove'] = array(
    '#type' => 'fieldset',
    '#title' => t('"Remove" popup'),
    '#collapsed' => FALSE,
    '#collapsible' => FALSE,
  );

  $form['modal']['remove']['width'] = array(
    '#type' => 'textfield',
    '#title' => t('Width'),
    '#default_value' => $settings['modal']['remove']['width'],
    '#element_validate' => array('editor_note_validate_size'),
    '#required' => TRUE,
    '#description' => t('Sets the width of an "Remove" popup. Accepts either numeric value (pixels) or "auto" (the browser calculates the width).'),
  );

  $form['modal']['remove']['height'] = array(
    '#type' => 'textfield',
    '#title' => t('Height'),
    '#default_value' => $settings['modal']['remove']['height'],
    '#element_validate' => array('editor_note_validate_size'),
    '#required' => TRUE,
    '#description' => t('Sets the height of an "Remove" popup. Accepts either numeric value (pixels) or "auto" (the browser calculates the height).'),
  );

  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters cardinality field of field settings form.
 */
function editor_note_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#field']['type'] == 'editor_note') {
    // Modifies cardinality field.
    $form['field']['cardinality']['#options'] = array(-1 => t('Unlimited')) +
      drupal_map_assoc(array(5, 10, 20, 30, 40, 50, 70, 100));
    $form['field']['cardinality']['#default_value'] = isset($form['field']['cardinality']['#default_value']) ?
      $form['field']['cardinality']['#default_value'] : -1;
    $form['field']['cardinality']['#description'] = t('Maximum number of values that field can store.');
  }
}

/**
 * Implements hook_field_widget_info().
 *
 * Registers widget for the field.
 */
function editor_note_field_widget_info() {
  return array(
    'editor_note_field_widget' => array(
      'label' => t('Editor Notes'),
      'field types' => array('editor_note'),
      'settings' => array(),
      'behaviors' => array(
        // @todo check if user is able to create multiple fields.
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 * Creates widget for the field, called for each field item.
 */
function editor_note_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($field['type'] == 'editor_note') {
    $element['note'] = array(
      '#type' => 'textarea',
      '#prefix' => '<div id="textarea_' . $field['field_name'] . '">',
      '#suffix' => '</div>',
      '#title' => check_plain($instance['label']),
      '#default_value' => isset($items[$delta]['note']) ? $items[$delta]['note'] : '',
      '#description' => check_plain($instance['description']),
      '#rows' => $field['settings']['notes_size'],
      '#resizable' => FALSE,
      '#attributes' => array(
        'maxlength' => $field['settings']['notes_maxlength'] > 0 ? $field['settings']['notes_maxlength'] : '',
        'placeholder' => t($field['settings']['notes_placeholder']),
      ),
    );

    if (isset($instance['entity_type']) && isset($form['#entity'])) {
      list($entity_id) = entity_extract_ids($instance['entity_type'], $form['#entity']);
    }

    if (isset($entity_id)) {
      // Display 'Add Note' button only if entity has been already created and stored in the database.
      $element['note_add'] = array(
        '#type' => 'submit',
        '#name' => $field['field_name'] . '_add_note',
        '#value' => t('Add Note'),
        '#submit' => array('editor_note_add_note_submit'),
        '#validate' => array('editor_note_add_note_validate'),
        '#limit_validation_errors' => array(array($field['field_name'])),
        '#ajax' => array(
          'callback' => 'editor_note_add_note',
          'event' => 'click',
        ),
      );

      $element['note_entity_id'] = array(
        '#type' => 'value',
        '#value' => $entity_id,
      );

      if (isset($form_state['triggering_element']['#name']) &&
        $form_state['triggering_element']['#name'] == $field['field_name'] . '_add_note') {
        // Fixing Ajax #default_value issue, @see https://drupal.org/node/1082818.
        unset($form_state['input'][$field['field_name']][LANGUAGE_NONE][0]['note']);
      }
    }
  }

  return $element;
}

/**
 * Implements hook_field_validate().
 *
 * Defines messages that will be shown on validation of widget form using hook_field_widget_error().
 */
function editor_note_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  if ($field['type'] == 'editor_note') {
    foreach ($items as $delta => $item) {
      if ($entity_type && $entity) {
        // Field widget form validation, otherwise field settings form.
        if (empty($item['note']) && $instance['required']) {
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'note',
            'message' => t('Field %name is required.', array('%name' => $instance['label'])),
          );
        }
      }
      if (!empty($item['note']) && $field['settings']['notes_maxlength'] > 0) {
        if (mb_strlen($item['note']) > $field['settings']['notes_maxlength']) {
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'notes_maxlength',
            'message' => t('%name: the value cannot not be longer than %max characters.',
              array('%name' => $instance['label'], '%max' => $field['settings']['notes_maxlength'])),
          );
        }
      }
      // Validate first element since there can be only 1 textarea for adding notes (even for multiple value field).
      break;
    }
  }
}

/**
 * Implements hook_field_widget_error().
 *
 * Displays validation errors if present and prevents form submit.
 */
function editor_note_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Implements hook_field_insert().
 *
 * Executes once on adding new entity to the database.
 */
function editor_note_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'editor_note') {
    foreach ($items as $item) {
      editor_note_save($item['note'], $entity_type, $entity, $field['field_name']);
    }
  }
}

/**
 * Implements hook_field_update().
 *
 * Executes every time entity gets updated.
 */
function editor_note_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'editor_note') {
    foreach ($items as $item) {
      editor_note_save($item['note'], $entity_type, $entity, $field['field_name']);
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * Registers formatter for the field.
 */
function editor_note_field_formatter_info() {
  return array(
    'editor_note_field_formatter' => array(
      'label' => t('Editor Notes table'),
      'field types' => array('editor_note'),
      'settings' => array(
        'limit' => 10,
        'order' => 'DESC',
        'display' => 1,
        'pager' => array(
          'enabled' => 1,
          'pager_below' => 1,
        ),
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 *
 * Creates field formatter forms for registered types of formatters.
 */
function editor_note_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $element = array();

  if ($display['type'] == 'editor_note_field_formatter') {
    $element['limit'] = array(
      '#type' => 'textfield',
      '#title' => t('Display a specified number of items.'),
      '#default_value' => $settings['limit'],
      '#required' => TRUE,
      '#description' => t('Display a specified number of items in table. Set 0 for no limit.'),
      '#element_validate' => array('editor_note_validate_integer_positive_or_zero'),
    );

    $element['order'] = array(
      '#type' => 'radios',
      '#title' => t('Order Notes'),
      '#options' => array(
        'DESC' => t('Display new notes first'),
        'ASC' => t('Display old notes first'),
      ),
      '#default_value' => $settings['order'],
      '#description' => t('Set order of notes in the table.'),
    );

    $element['pager'] = array(
      '#type' => 'fieldset',
      '#title' => t('Pagination'),
      '#collapsed' => FALSE,
      '#collapsible' => FALSE,
      '#states' => array(
        'invisible' => array(
          'input[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][limit]"]' =>
            array('value' => 0),
        ),
      ),
    );

    $element['pager']['enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable pagination'),
      '#default_value' => $settings['pager']['enabled'],
      '#description' => t('Whether to display pagination if number of notes added is greater that can be displayed.'),
    );

    $element['pager']['pager_below'] = array(
      '#type' => 'checkbox',
      '#title' => t('Pagination below notes table'),
      '#default_value' => $settings['pager']['pager_below'],
      '#description' => t('Displays pagination below the notes table, if unchecked pagination displays above the table.'),
      '#states' => array(
        'invisible' => array(
          'input[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][pager][enabled]"]' =>
            array('checked' => FALSE),
        ),
      ),
    );
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 *
 * Displays summary of enabled settings for the field on Manage Display page.
 * Essential for proper work of hook_field_formatter_settings_form() because it adds
 * ajax-powered button that opens formatter_settings_form.
 * Note that button is present only if this hook returns non empty value.
 * @see field_ui_display_overview_form().
 */
function editor_note_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $summary = array();

  if ($display['type'] == 'editor_note_field_formatter') {
    $summary[] = t('Display a specified number of items') . ': ' . $display['settings']['limit'];
    $summary[] = t('Notes Ordering') . ': ' .
      ($settings['order'] == 'DESC' ? t('display new notes first') : t('display old notes first'));
    if ($display['settings']['limit'] > 0) {
      $summary[] = t('Enable pagination') . ': ' . ($settings['pager']['enabled'] ? 'true' : 'false');
      $summary[] = t('Pagination below notes table') . ': ' .
        ($settings['pager']['pager_below'] ? 'true' : 'false');
    }
  }

  return !empty($summary) ? implode('<br />', $summary) : '';
}

/**
 * Implements hook_field_load().
 *
 * Defines custom load behavior for the field properties available in entity object.
 */
function editor_note_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  if ($field['type'] == 'editor_note') {
    foreach ($entities as $id => $entity) {
      $delta = 0;
      $notes = editor_note_get_notes($entity_type, $entity, $field, TRUE);
      foreach ($notes as $note_id) {
        $items[$id][$delta]['editor_note_id'] = $note_id;
        $delta++;
      }
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 *
 * Builds registered formatters for the field, returns renderable array.
 */
function editor_note_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $display['field_name'] = $field['field_name'];
  if ($display['type'] == 'editor_note_field_formatter') {
    $notes = editor_note_get_notes($entity_type, $entity, $display);
    $element[][$field['field_name']] = editor_note_get_formatted_notes($display, $notes);
  }

  return $element;
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Replaces default 'field_multiple_value_form' theme function with a custom function.
 */
function editor_note_theme_registry_alter(&$theme_registry) {
  if (isset($theme_registry['field_multiple_value_form'])) {
    $theme_registry['field_multiple_value_form']['type'] = 'module';
    $theme_registry['field_multiple_value_form']['theme path'] = drupal_get_path('module', ' notes_field');
    $theme_registry['field_multiple_value_form']['function'] =  'editor_note_theme_field_multiple_value_form';
  }
}

/**
 * Overrides multiple-value form widget for 'notes' field widget form.
 *
 * @see theme_field_multiple_value_form().
 *
 * @param array $variables
 *
 * @return array
 */
function editor_note_theme_field_multiple_value_form($variables) {
  $element = $variables['element'];
  $field_info = field_info_field($variables['element']['#field_name']);
  if ($field_info['type'] == 'editor_note') {
    // Custom function for 'notes' field widget form.
    // 'Notes' cardinality is always > 1 because 'editor notes' field makes sense
    // when at least 2 editors work on same material.
    $output = editor_note_theme_widget_form($variables, $element);
  }
  else {
    // Otherwise default theme function.
    $output = theme_field_multiple_value_form($variables);
  }

  return $output;
}

/**
 * Custom widget form for 'notes' field.
 *
 * @param array $variables
 * @param array $element
 *
 * @return string
 */
function editor_note_theme_widget_form($variables, $element) {
  $output = array();
  $add_note_widget = array();

  $field = field_info_field($element['#field_name']);
  $notes = editor_note_get_notes($element[0]['#entity_type'], $element[0]['#entity'], $field);
  $formatted_notes = editor_note_get_formatted_notes($field, $notes, TRUE);

  // Cardinality by default -1 for unlimited values.
  if ($field['cardinality'] < 0 || count($notes) < $field['cardinality']) {
    $add_note_widget = $element[0];
    $required = $element['#required'] ? ' ' . theme('form_required_marker', $variables) : '';
    if ($required) {
      // Adds required mark to the title of 'Add Note' field.
      $add_note_widget['note']['#title'] .= $required;
    }
    if (isset($add_note_widget['_weight'])) {
      // Hides $items['_weight'] from display.
      $add_note_widget['_weight']['#attributes']['class'][] = 'element-invisible';
    }
  }

  $status_message_container = array(
    '#theme' => 'html_tag',
    '#tag' => 'div',
    '#attributes' => array(
      'id' => array('status_message_' . $element['#field_name']),
    ),
    '#value' => '',
  );

  if ($field['settings']['display']) {
    $output[] = drupal_render($add_note_widget);
    $output[] = drupal_render($status_message_container);
    $output[] = drupal_render($formatted_notes);
  }
  else {
    $output[] = drupal_render($formatted_notes);
    $output[] = drupal_render($status_message_container);
    $output[] = drupal_render($add_note_widget);
  }

  return '<div class="form-item">' . implode('', $output) . '</div>';
}

/**
 * Saves note.
 *
 * @param string $note
 * @param string $entity_type
 * @param object $entity
 * @param string $field_name
 * @param int|string|null $uid
 * @param int|string|null $created
 * @param int|string|null $changed
 */
function editor_note_save($note, $entity_type, $entity, $field_name, $uid = NULL, $created = NULL, $changed = NULL) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!isset($revision_id)) {
    $revision_id = $entity_id;
  }
  if (!isset($uid)) {
    global $user;
    $uid = $user->uid;
  }
  $editor_note = entity_create(
    'editor_note', array(
      'note' => $note,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
      'field_name' => $field_name,
      'entity_id' => $entity_id,
      'revision_id' => $revision_id,
      'uid' => (int) $uid,
      'created' => isset($created) ? $created : REQUEST_TIME,
      'changed' => isset($changed) ? $changed : REQUEST_TIME,
    )
  );
  entity_save('editor_note', $editor_note);
}

/**
 * Loads single note based on certain conditions.
 *
 * @param int|string $note_id
 * @param array $conditions
 * @param bool $reset
 *
 * @return int|bool
 */
function editor_note_load($note_id, $conditions = array(), $reset = FALSE) {
  $note_array = entity_load('editor_note', array($note_id), $conditions, $reset);
  if (!empty($note_array)) {
    return $note_array[$note_id];
  }

  return FALSE;
}

/**
 * Loads multiple notes based on certain conditions.
 *
 * @param $note_ids
 * @param array $conditions
 * @param bool $reset
 *
 * @return bool|object
 */
function editor_note_load_multiple($note_ids, $conditions = array(), $reset = FALSE) {
  return entity_load('editor_note', $note_ids, $conditions, $reset);
}

/**
 * Deletes single note.
 *
 * @param $note_id
 */
function editor_note_delete($note_id) {
  entity_delete('editor_note', $note_id);
}

/**
 * Deletes multiple notes.
 *
 * @param int|string $note_ids
 */
function editor_note_delete_multiple($note_ids) {
  entity_delete_multiple('editor_note', $note_ids);
}

/**
 * Returns array of notes per entity revision.
 *
 * @param string $entity_type
 * @param object $entity
 * @param array $field
 * @param bool $id_only returns array of note ids instead of fully loaded notes.
 *
 * @return mixed
 */
function editor_note_get_notes($entity_type, $entity, $field, $id_only = FALSE) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!isset($revision_id)) {
    $revision_id = $entity_id;
  }

  $query = db_select('editor_note', 'en');
  $query->condition('en.entity_type', $entity_type, '=')
    ->condition('en.entity_id', $entity_id, '=')
    ->condition('en.bundle', $bundle, '=')
    ->condition('en.revision_id', $revision_id, '=')
    ->condition('en.field_name', $field['field_name'], '=')
    ->orderBy('en.changed', $field['settings']['order']);

  if ($id_only) {
    $ids = $query->fields('en', array('id'))->execute()->fetchAllKeyed(0, 0);
    return array_values($ids);
  }

  $columns = array(
    'id',
    'note',
    'entity_type',
    'bundle',
    'field_name',
    'entity_id',
    'revision_id',
    'uid',
    'created',
    'changed',
  );

  $query->fields('en', $columns);

  if ($field['settings']['limit'] > 0) {
    if ($field['settings']['pager']['enabled']) {
      $query = $query->extend('PagerDefault');
      $query->limit($field['settings']['limit']);
    }
    else {
      $query->range(0, $field['settings']['limit']);
    }
  }

  return $query->execute()->fetchAllAssoc('id');
}

/**
 * Returns formatted notes table.
 *
 * @param array $field
 * @param array $notes
 * @param bool $widget
 * @param string|null $edit_path
 *
 * @return array
 */
function editor_note_get_formatted_notes($field, $notes, $widget = FALSE, $edit_path = NULL) {
  $formatted_notes = array(
    '#prefix' => '<div id="formatted_notes_' . $field['field_name'] . '">',
    '#suffix' => '</div>',
  );

  if (!empty($notes)) {
    $rows = array();
    $counter = 0;

    $header = array(
      array(
        'data' => t('Notes'),
        'class' => array('field-label'),
      ),
      array(
        'data' => t('Updated by'),
        'class' => array('field-author'),
      ),
      array(
        'data' => t('Changed'),
        'class' => array('field-changed'),
      ),
      array(
        'data' => t('Created'),
        'class' => array('field-created'),
      ),
    );

    if ($widget) {
      $header[] = array(
        'data' => t('Actions'),
        'class' => array('field-operations'),
      );

      editor_note_load_ctools_modal($field);
    }

    foreach ($notes as $note_id => $item) {
      $author_name = format_username(user_load($item->uid));
      $rows[$counter] = array(
        'data' => array(
          'note' => array(
            'data' => $item->note,
            'class' => array('note'),
          ),
          'author' => array(
            'data' => user_access('access user profiles') ? l($author_name, 'user/' . $item->uid) : $author_name,
            'class' => array('author'),
          ),
          'changed' => array(
            'data' => format_date($item->changed, 'short'),
            'class' => array('changed'),
          ),
          'created' => array(
            'data' => format_date($item->created, 'short'),
            'class' => array('created'),
          ),
        ),
        'class' => array(drupal_html_class('note-' . $note_id)),
      );

      if ($widget) {
        $operations = !editor_note_access_crud_operations($note_id) ? '' : theme(
          'item_list',
          array(
            'items' => array(
              ctools_modal_text_button(
                t('edit'),
                'editor_note/edit/nojs/' . $note_id,
                t('Edit the note'),
                drupal_html_class('ctools-modal-' . $field['field_name'] . '-edit')
              ),
              ctools_modal_text_button(
                t('remove'),
                'editor_note/remove/nojs/' . $note_id,
                t('Remove the note'),
                drupal_html_class('ctools-modal-' . $field['field_name'] . '-remove')
              ),
            ),
          )
        );
        $rows[$counter]['data']['operations'] = array(
          'data' => $operations,
          'class' => array('operations'),
        );
      }
      $counter++;
    }

    $notes_table = array(
      '#theme' => 'table',
      '#header' => $header,
      '#rows' => $rows,
      '#attributes' => array(
        'class' => array('field-notes-table'),
      )
    );

    if ($field['settings']['pager']['enabled']) {
      // Fixes pager on ajax refresh. Otherwise pager links point on /system/ajax after ajax refresh.
      // @see https://www.drupal.org/node/1181370#comment-6088864 for more details.
      // @see theme_pager_link().
      if ($edit_path) {
        $_GET['q'] = $edit_path;
      }

      if ($field['settings']['pager']['pager_below']) {
        $formatted_notes['notes_table'] = $notes_table;
        $formatted_notes['notes_table_pager'] = array(
          '#theme' => 'pager',
        );
      }
      else {
        $formatted_notes['notes_table_pager'] = array(
          '#theme' => 'pager',
        );
        $formatted_notes['notes_table'] = $notes_table;
      }

      if (module_exists('field_group')) {
        // Remember which tab was active after page reload when navigating between pager links.
        $settings = array(
          'editorNoteContainer' => drupal_html_class('edit-' . $field['field_name']),
        );
        $formatted_notes['notes_table']['#attached']['js'][] = array('data' => $settings, 'type' => 'setting');
        $formatted_notes['notes_table']['#attached']['js'][] = drupal_get_path('module', 'editor_note') . '/js/editor_note.js';
      }
    }
    else {
      $formatted_notes['notes_table'] = $notes_table;
    }
  }

  return $formatted_notes;
}

/**
 * Defines access callback for CRUD operations.
 *
 * @param int|string $note_id
 *
 * @return bool
 */
function editor_note_access_crud_operations($note_id) {
  global $user;
  $note_uid = db_query('SELECT en.uid FROM {editor_note} en WHERE id = :id',
    array(':id' => $note_id))->fetchField();

  return user_access('administer any editor note') || $user->uid == $note_uid;
}

/**
 * Creates form element validation handler for integer elements that must be positive or 0.
 *
 * @param array $element
 * @param array $form_state
 */
function editor_note_validate_integer_positive_or_zero($element, &$form_state) {
  // Checks for positive integer (or zero) value.
  preg_match('/^[0-9]\d*$/', trim($element['#value']), $matches);
  if (empty($matches)) {
    form_error($element, t('%name must be a positive integer or 0.', array('%name' => $element['#title'])));
  }
}

/**
 * Creates form element validation handler for float elements that must be >= 0 or <= 1.
 *
 * @param array $element
 * @param array $form_state
 */
function editor_note_validate_float_positive_or_zero($element, &$form_state) {
  $value = trim($element['#value']);
  if (!is_numeric($value) || $value < 0 || $value > 1) {
    form_error($element, t('%name must be between 0 and 1.', array('%name' => $element['#title'])));
  }
}

/**
 * Creates form element validation handler for HEX value.
 *
 * @param array $element
 * @param array $form_state
 */
function editor_note_validate_hex($element, &$form_state) {
  preg_match('/^[0-9A-Fa-f]{6}$/', trim($element['#value']), $matches);
  if (empty($matches)) {
    form_error($element, t('%name should contain combination of 6 [0-9A-Fa-f] symbols.', array('%name' => $element['#title'])));
  }
}

/**
 * Creates form element validation handler for HEX value.
 *
 * @param array $element
 * @param array $form_state
 */
function editor_note_validate_size($element, &$form_state) {
  $value = $element['#value'];
  if ((is_string($value) && $value !== 'auto') &&
    ($value !== '' && (!is_numeric($value) || intval($value) != $value || $value <= 0))) {
    $error = t('%name accepts either positive integer value (pixels) or "auto" (the browser calculates the height).',
      array('%name' => $element['#title']));
    form_error($element, $error);
  }
}

/**
 * Builds confirmation form for removing the note which displays in popup.
 *
 * @param array $form
 * @param array $form_state
 * @param int|string $id
 *
 * @return array
 */
function editor_note_confirm_remove_form($form, $form_state, $id) {
  $form = array();
  $note = editor_note_load(arg(3));

  if ($note) {
    $form['note'] = array(
      '#markup' => '<p>' . t('Are you sure you want to remove the note? This action cannot be undone.') . '</p>',
    );

    $form['note_id'] = array(
      '#type' => 'value',
      '#value' => $note->id,
    );

    $form['note_entity_type'] = array(
      '#type' => 'value',
      '#value' => $note->entity_type,
    );

    $form['note_entity_id'] = array(
      '#type' => 'value',
      '#value' => $note->entity_id,
    );

    $form['note_field_name'] = array(
      '#type' => 'value',
      '#value' => $note->field_name,
    );

    $form['actions'] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array('element-inline', 'editor-note-actions'),
      ),
    );

    $form['actions']['cancel'] = array(
      '#type' => 'submit',
      '#value' => t('Cancel'),
      '#submit' => array('editor_note_confirm_form_cancel'),
    );

    $form['actions']['delete'] = array(
      '#type' => 'submit',
      '#value' => t('Remove'),
      '#submit' => array('editor_note_confirm_remove_form_remove'),
    );
  }
  else {
    $form['note'] = array(
      '#markup' => '<p>' . t('Selected note could not be loaded. Cancel action and reload the page to refresh notes widget.') . '</p>',
    );

    $form['actions']['cancel'] = array(
      '#type' => 'submit',
      '#value' => t('Cancel'),
      '#submit' => array('editor_note_confirm_form_cancel'),
    );
  }

  return $form;
}

/**
 * Ajax callback for 'Cancel' button in 'editor_note_confirm_remove_form'.
 *
 * @param array $form
 * @param array $form_state
 */
function editor_note_confirm_form_cancel(&$form, &$form_state) {
  $field_name = $form_state['values']['note_field_name'];

  // Closes the modal.
  $form_state['ajax_commands'][] = ctools_modal_command_dismiss();

  // Removes previous status message.
  $message = theme('editor_note_message', array('field_name' => $field_name));

  $form_state['ajax_commands'][] = ajax_command_replace('#status_message_' . $field_name, $message);
}

/**
 * Ajax callback for 'Remove' button in 'editor_note_confirm_remove_form'.
 *
 * @param array $form
 * @param array $form_state
 */
function editor_note_confirm_remove_form_remove(&$form, &$form_state) {
  $field_name = $form_state['values']['note_field_name'];
  $entity_type = $form_state['values']['note_entity_type'];
  $entity_id = $form_state['values']['note_entity_id'];
  $note_id = $form_state['values']['note_entity_id'];
  $edit_path = implode('/', array($entity_type, $entity_id, 'edit'));

  // Removes note entity from the database.
  editor_note_delete($form_state['values']['note_id']);

  // Closes the modal.
  $form_state['ajax_commands'][] = ctools_modal_command_dismiss();

  // Displays remove message.
  $message = theme(
    'editor_note_message',
    array(
      'field_name' => $field_name,
      'message_text' => t('Note has been removed.'),
      'message_type' => 'status',
    )
  );

  $form_state['ajax_commands'][] = ajax_command_replace('#status_message_' . $field_name, $message);

  // Updates notes table and pager.
  $field = field_info_field($field_name);
  $entity_array = entity_load($entity_type, array($entity_id));
  $entity = $entity_array[$note_id];
  $notes = editor_note_get_notes($entity_type, $entity, $field);
  $formatted_notes = editor_note_get_formatted_notes($field, $notes, TRUE, $edit_path);
  $form_state['ajax_commands'][] = ajax_command_replace('#formatted_notes_' . $field_name, drupal_render($formatted_notes));
}

/**
 * Builds confirmation form for editing the note which displays in popup.
 *
 * @param array $form
 * @param array $form_state
 * @param int|string $id
 *
 * @return array
 */
function editor_note_confirm_edit_form($form, $form_state, $id) {
  $form = array();
  $note = editor_note_load(arg(3));

  if ($note) {
    $field = field_info_field($note->field_name);

    $form['note'] = array(
      '#type' => 'textarea',
      '#title' => t('Update Note'),
      '#default_value' => $note->note,
      '#required' => TRUE,
      '#rows' => $field['settings']['notes_size'],
      '#resizable' => FALSE,
      '#attributes' => array(
        'maxlength' => $field['settings']['notes_maxlength'] > 0 ? $field['settings']['notes_maxlength'] : '',
        'placeholder' => t($field['settings']['notes_placeholder']),
      ),
    );

    $form['note_id'] = array(
      '#type' => 'value',
      '#value' => $note->id,
    );

    $form['note_entity_type'] = array(
      '#type' => 'value',
      '#value' => $note->entity_type,
    );

    $form['note_entity_id'] = array(
      '#type' => 'value',
      '#value' => $note->entity_id,
    );

    $form['note_field_name'] = array(
      '#type' => 'value',
      '#value' => $note->field_name,
    );

    $form['actions'] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array('element-inline', 'editor-note-actions'),
      ),
    );

    $form['actions']['cancel'] = array(
      '#type' => 'submit',
      '#value' => t('Cancel'),
      '#submit' => array('editor_note_confirm_form_cancel'),
    );

    $form['actions']['update'] = array(
      '#type' => 'submit',
      '#value' => t('Update'),
      '#submit' => array('editor_note_confirm_edit_form_update'),
    );
  }
  else {
    $form['note'] = array(
      '#markup' => '<p>' . t('Selected note could not be loaded. Cancel action and reload the page to refresh notes widget.') . '</p>',
    );

    $form['actions']['cancel'] = array(
      '#type' => 'submit',
      '#value' => t('Cancel'),
      '#submit' => array('editor_note_confirm_form_cancel'),
    );
  }

  return $form;
}

/**
 * Ajax callback for 'Update' button in 'editor_note_confirm_edit_form'.
 *
 * @param array $form
 * @param array $form_state
 */
function editor_note_confirm_edit_form_update(&$form, &$form_state) {
  global $user;
  $field_name = $form_state['values']['note_field_name'];
  $entity_type = $form_state['values']['note_entity_type'];
  $entity_id = $form_state['values']['note_entity_id'];
  $note_id = $form_state['values']['note_id'];
  $field = field_info_field($field_name);
  $edit_path = implode('/', array($entity_type, $entity_id, 'edit'));

  // Updates note entity in the database.
  $note = editor_note_load($note_id);
  $note->note = $form_state['values']['note'];
  $note->changed = REQUEST_TIME;
  $note->uid = $user->uid;
  $note->save();

  // Closes the modal.
  $form_state['ajax_commands'][] = ctools_modal_command_dismiss();

  // Displays remove message.
  $message = theme(
    'editor_note_message',
    array(
      'field_name' => $field_name,
      'message_text' => t('Note has been updated and saved.'),
      'message_type' => 'status',
    )
  );

  $form_state['ajax_commands'][] = ajax_command_replace('#status_message_' . $field_name, $message);

  // Updates notes table and pager.
  $entity_array = entity_load($entity_type, array($entity_id));
  $entity = $entity_array[$entity_id];
  $notes = editor_note_get_notes($entity_type, $entity, $field);
  $formatted_notes = editor_note_get_formatted_notes($field, $notes, TRUE, $edit_path);
  $form_state['ajax_commands'][] = ajax_command_replace('#formatted_notes_' . $field_name, drupal_render($formatted_notes));
}

/**
 * Ajax callback for 'Add note' button in 'editor_note_field_widget_form'.
 *
 * @param array $form
 * @param array $form_state
 *
 * @return array
 */
function editor_note_add_note(&$form, &$form_state) {
  $ajax_commands = array();
  $entity_type = $form['#entity_type'];
  $entity = $form['#entity'];
  $field_name = str_replace('_add_note', '', $form_state['triggering_element']['#name']);
  $note = $form_state['values'][$field_name][LANGUAGE_NONE][0]['note'];
  $entity_id = $form_state['values'][$field_name][LANGUAGE_NONE][0]['note_entity_id'];
  $edit_path = implode('/', array($entity_type, $entity_id, 'edit'));
  $errors = form_get_errors();

  if (!empty($errors) && isset($errors[$field_name])) {
    // Displays validation message.
    $message = theme(
      'editor_note_message',
      array(
        'field_name' => $field_name,
        'message_text' => t($errors[$field_name]),
        'message_type' => 'error',
      )
    );

    $ajax_commands[] = ajax_command_replace('#status_message_' . $field_name, $message);

    // Returns textarea for adding notes with red border indicates that an error has occurred.
    $ajax_commands[] = ajax_command_replace('#textarea_' . $field_name, drupal_render($form[$field_name][LANGUAGE_NONE][0]['note']));
  }
  else {
    // Adds note entity to the database.
    editor_note_save($note, $entity_type, $entity, $field_name);

    // Displays status message.
    $message = theme(
      'editor_note_message',
      array(
        'field_name' => $field_name,
        'message_text' => t('Note has been added and saved.'),
        'message_type' => 'status',
      )
    );

    $ajax_commands[] = ajax_command_replace('#status_message_' . $field_name, $message);

    // Updates notes table and pager.
    $field = field_info_field($field_name);
    $notes = editor_note_get_notes($entity_type, $entity, $field);
    $formatted_notes = editor_note_get_formatted_notes($field, $notes, TRUE, $edit_path);
    $ajax_commands[] = ajax_command_replace('#formatted_notes_' . $field_name, drupal_render($formatted_notes));

    // Returns blank textarea for adding notes.
    $form[$field_name][LANGUAGE_NONE][0]['note']['#default_value'] = '';
    $ajax_commands[] = ajax_command_replace('#textarea_' . $field_name, drupal_render($form[$field_name][LANGUAGE_NONE][0]['note']));
  }

  return array(
    '#type' => 'ajax',
    '#commands' => $ajax_commands,
  );
}

/**
 * Validate callback for 'editor_note_field_widget_form'.
 *
 * @param array $form
 * @param array $form_state
 */
function editor_note_add_note_validate(&$form, &$form_state) {
  $field_name = str_replace('_add_note', '', $form_state['triggering_element']['#name']);
  $field_info = field_info_instance($form['#entity_type'], $field_name, $form['#bundle']);
  if (empty($form_state['values'][$field_name][LANGUAGE_NONE][0]['note'])) {
    form_set_error($field_name, t('Field %field_name is required.', array('%field_name' => $field_info['label'])));
  }
}

/**
 * Submit callback for 'editor_note_field_widget_form'.
 *
 * @param array $form
 * @param array $form_state
 */
function editor_note_add_note_submit(&$form, &$form_state) {
  $form_state['rebuild'] = TRUE;
}

/**
 * Builds confirmation page for removing selected note.
 *
 * @param string|null $ajax
 * @param string|int|null $id
 *
 * @return null|array
 */
function editor_note_confirm_remove_page($ajax = NULL, $id = NULL) {
  if ($id == NULL) {
    return t('Error: no note id was sent.');
  }

  if ($ajax) {
    ctools_include('ajax');
    ctools_include('modal');

    $form_state = array(
      'ajax' => TRUE,
      'title' => t('Are you sure you want to delete the note?'),
    );

    $output = ctools_modal_form_wrapper('editor_note_confirm_remove_form', $form_state);
    // If the form has been submitted, there may be additional instructions
    // such as dismissing the modal popup.
    if (!empty($form_state['ajax_commands'])) {
      $output = $form_state['ajax_commands'];
    }

    // Returns the ajax instructions to the browser via ajax_render().
    print ajax_render($output);
    drupal_exit();
  }
  else {
    return drupal_get_form('editor_note_confirm_remove_form', $id);
  }
}

/**
 * Builds confirmation page for updating selected note.
 *
 * @param string|null $ajax
 * @param string|int|null $id
 *
 * @return null|array
 */
function editor_note_confirm_edit_page($ajax = NULL, $id = NULL) {
  if ($id == NULL) {
    return t('Error: no note id was sent.');
  }

  if ($ajax) {
    ctools_include('ajax');
    ctools_include('modal');

    $form_state = array(
      'ajax' => TRUE,
      'title' => t('Update selected item'),
    );

    $output = ctools_modal_form_wrapper('editor_note_confirm_edit_form', $form_state);
    // If the form has been submitted, there may be additional instructions
    // such as dismissing the modal popup.
    if (!empty($form_state['ajax_commands'])) {
      $output = $form_state['ajax_commands'];
    }

    // Returns the ajax instructions to the browser via ajax_render().
    print ajax_render($output);
    drupal_exit();
  }
  else {
    return drupal_get_form('editor_note_confirm_edit_form', $id);
  }
}

/**
 * Enables support of CTools module for Ajax operations.
 *
 * @param array $field
 */
function editor_note_load_ctools_modal($field) {
  // Includes the CTools tools that we need.
  ctools_include('ajax');
  ctools_include('modal');

  // Adds CTools' javascript to the page.
  ctools_modal_add_js();

  // Creates javascript settings to customize modal.
  $modal_styles = array(
    drupal_html_class($field['field_name'] . '-remove') => array(
      'modalSize' => array(
        'type' => 'fixed',
        'width' => $field['settings']['modal']['remove']['width'] == 'auto' ?
            $field['settings']['modal']['remove']['width'] : (int) $field['settings']['modal']['remove']['width'],
        'height' => $field['settings']['modal']['remove']['height'] == 'auto' ?
            $field['settings']['modal']['remove']['height'] : (int) $field['settings']['modal']['remove']['height'],
      ),
      'modalOptions' => array(
        'opacity' => $field['settings']['modal']['overlay']['opacity'],
        'background-color' => '#' . $field['settings']['modal']['overlay']['bgcolor'],
      ),
      'animation' => 'show',
    ),
    drupal_html_class($field['field_name'] . '-edit') => array(
      'modalSize' => array(
        'type' => 'fixed',
        'width' => $field['settings']['modal']['edit']['width'] == 'auto' ?
            $field['settings']['modal']['edit']['width'] : (int) $field['settings']['modal']['edit']['width'],
        'height' => $field['settings']['modal']['edit']['height'] == 'auto' ?
            $field['settings']['modal']['edit']['height'] : (int) $field['settings']['modal']['edit']['height'],
      ),
      'modalOptions' => array(
        'opacity' => $field['settings']['modal']['overlay']['opacity'],
        'background-color' => '#' . $field['settings']['modal']['overlay']['bgcolor'],
      ),
      'animation' => 'show',
    ),
  );

  // Passes CTools modal settings to js.
  drupal_add_js($modal_styles, 'setting');

  // Adds custom css to style popups.
  ctools_add_css('editor-note-ctools-style', 'editor_note');
}

/**
 * Returns formatted status message for Ajax-triggered actions.
 *
 * @param array $variables
 *
 * @return string
 */
function theme_editor_note_message($variables) {
  $field_name = $variables['field_name'];
  $message_text = $variables['message_text'];
  $message_type = $variables['message_type'];

  if (!empty($message_text) && !empty($message_type)) {
    return '<div id="status_message_' . $field_name . '">
    <div class="messages ' . $message_type . '">' . $message_text . '</div></div>';
  }
  else {
    return '<div id="status_message_' . $field_name . '"></div>';
  }
}
