<?php

/**
 * @file
 * Main functionality for Notes Field module.
 */

/**
 * @todo textarea (delta 0) and table (delta >= 1)
 * @todo check on /node/add/ - should not be possible to add notes via ajax on empty node
 * @todo think about field permissions
 * @todo test with multiple languages
 * @todo test with revisions
 */

/**
 * Implements hook_entity_info().
 */
function editor_note_entity_info() {
  $entity = array(
    'editor_note' => array(
      'label' => t('Editor Note'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'editor_note',
      'entity keys' => array(
        'id' => 'id',
      ),
      'module' => 'editor_note',
    ),
  );

  return $entity;
}

/**
 * Implements hook_entity_property_info().
 */
function editor_note_entity_property_info() {
  $properties = array(
    'id' => array(
      'type'  => 'integer',
      'label' => t('Editor Note ID'),
      'description' => t('Unique editor note ID.'),
      'schema field' => 'id',
    ),
    'note' => array(
      'type'  => 'text',
      'label' => t('Editor Note'),
      'description' => t('Content of editor note.'),
      'schema field' => 'note',
    ),
    'entity_type' => array(
      'type' => 'text',
      'label' => t('Entity Type'),
      'description' => 'The entity type editor note is attached to.',
      'schema field' => 'entity_type',
    ),
    'entity_id' => array(
      'type' => 'int',
      'label' => t('Entity ID'),
      'description' => 'The entity id editor note is attached to.',
      'schema field' => 'entity_type',
    ),
    'revision_id' => array(
      'type' => 'int',
      'label' => t('Revision ID'),
      'description' => 'The entity revision editor note is attached to.',
      'schema field' => 'revision_id',
    ),
    'uid' => array(
      'type'  => 'integer',
      'label' => t('Author UID'),
      'description' => t('The unique ID of the user who authored editor note.'),
      'schema field' => 'uid',
    ),
    'created' => array(
      'type' => 'int',
      'label' => t('Created'),
      'description' => 'The time that the note was created.',
      'schema field' => 'created',
    ),
    'changed' => array(
      'type' => 'int',
      'label' => t('Changed'),
      'description' => 'The time that the note was last edited.',
      'schema field' => 'changed',
    ),
  );

  $info['note']['properties'] = $properties;

  return $info;
}

/**
 * Implements hook_field_info().
 */
function editor_note_field_info() {
  return array(
    'editor_note' => array(
      'label' => t('Editor Notes'),
      'description' => t('Field for taking editor notes.'),
      'settings' => array(
        'notes_size' => 3,
        'notes_placeholder' => 'Create a note',
        'notes_maxlength' => 0, // @todo test if it works in IE and perform server-side validation
        'limit' => 10,
        'order' => 'DESC',
        'display' => 1,
        'pager' => 1,
        'pager_below' => 1,
      ),
      'instance_settings' => array(),
      'default_widget' => 'editor_note_field_widget',
      'default_formatter' => 'editor_note_field_formatter',
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function editor_note_field_is_empty($item, $field) {
  // @todo update hook with actual values.
  if (empty($item['note']) && $item['note'] !== '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_field_settings_form().
 */
function editor_note_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];

  $form['notes_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size of Notes field (rows)'),
    '#default_value' => $settings['notes_size'],
    '#required' => TRUE,
    '#description' => t('Specify the visible number of lines in textarea for adding note.'),
    '#element_validate' => array('element_validate_integer_positive'),
  );

  $form['notes_placeholder'] = array(
    '#type' => 'textfield',
    '#title' => t('Placeholder for blank Notes field'),
    '#default_value' => $settings['notes_placeholder'],
    '#required' => FALSE,
    '#description' => t('Specifies a short hint that describes the expected value of the textarea.'),
  );

  $form['notes_maxlength'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of characters user can enter'),
    '#default_value' => $settings['notes_maxlength'],
    '#required' => TRUE,
    '#description' => t('Specifies the maximum number of characters allowed in the textarea. Set 0 for no limit.'),
    '#element_validate' => array('editor_note_validate_integer_positive_or_zero'),
  );

  $form['limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Display a specified number of items.'),
    '#default_value' => $settings['limit'],
    '#required' => TRUE,
    '#description' => t('Display a specified number of items. Set 0 for no limit.'),
    '#element_validate' => array('editor_note_validate_integer_positive_or_zero'),
  );

  $form['order'] = array(
    '#type' => 'radios',
    '#title' => t('Order Notes'),
    '#options' => array(
      'DESC' => t('Display new notes first'),
      'ASC' => t('Display old notes first'),
    ),
    '#default_value' => $settings['order'],
    '#description' => t('Set order of notes in the table.'),
  );

  $form['display'] = array(
    '#type' => 'checkbox',
    '#title' => t('Textarea above notes table'),
    '#default_value' => $settings['display'],
    '#description' => t('Display "Create a note" field above the notes table. Otherwise it will be shown below the notes table.'),
  );

  $form['pager'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display pager'),
    '#default_value' => $settings['pager'],
    '#description' => t('Whether to display pager if number of notes added is greater that can be displayed.'),
  );

  // @todo implement #states to hide pager when limit = 0

  $form['pager'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display pager'),
    '#default_value' => $settings['pager'],
    '#description' => t('Whether to display pager if number of notes added is greater that can be displayed.'),
  );

  $form['pager_below'] = array(
    '#type' => 'checkbox',
    '#title' => t('Pager below notes table'),
    '#default_value' => $settings['pager_below'],
    '#description' => t('Display pager below the notes table. Otherwise it will be shown above the notes table.'),
  );

  // @todo implement #states to hide pager_display when pager = 0
  // @todo add validation so that user cannot add pager and set limit 0 at the same time.

  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function editor_note_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#field']['type'] == 'editor_note') {
    // Update cardinality field.
    $form['field']['cardinality']['#options'] = array(-1 => t('Unlimited')) +
      drupal_map_assoc(array(5, 10, 20, 30, 40, 50, 70, 100));
    $form['field']['cardinality']['#default_value'] = isset($form['field']['cardinality']['#default_value']) ?
      $form['field']['cardinality']['#default_value'] : -1;
    $form['field']['cardinality']['#description'] = t('Maximum number of values users can enter for this field.');
  }
}

/**
 * Implements hook_field_validate().
 */
// @todo validate so that editor cannot change values in hidden fields manually and then to save field.
// @todo check field on preview and validation.
function editor_note_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
//  foreach ($items as $delta => $item) {
//    if (!empty($item['value'])) {
//      if (!empty($field['settings']['max_length']) && drupal_strlen($item['value']) > $field['settings']['max_length']) {
//        $errors[$field['field_name']][$langcode][$delta][] = array(
//          'error' => 'text_max_length',
//          'message' => t('%name: the value may not be longer than %max characters.', array('%name' => $instance['label'], '%max' => $field['settings']['max_length'])),
//        );
//      }
//    }
//  }
}

/**
 * Implements hook_field_widget_info().
 */
function editor_note_field_widget_info() {
  return array(
    'editor_note_field_widget' => array(
      'label' => t('Editor Notes'),
      'field types' => array('editor_note'),
      'settings' => array(),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT, // @todo implement that user can create 2 (? 3) or more fields.
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function editor_note_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element['note'] = array(
    '#type' => 'textarea',
    '#title' => $instance['label'],
    '#default_value' => isset($items[$delta]['note']) ? $items[$delta]['note'] : '',
    '#attributes' => array(
      'maxlength' => $field['settings']['notes_maxlength'] > 0 ? $field['settings']['notes_maxlength'] : '',
      'placeholder' => t($field['settings']['notes_placeholder']),
    ),
  );

  $element['id'] = array(
    '#type' => 'hidden',
    '#default_value' => isset($items[$delta]['id']) ? $items[$delta]['id'] : '',
  );

  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function editor_note_field_widget_error($element, $error, $form, &$form_state) {
//  form_error($element, $error['message']);
}

/**
 * Implements hook_field_insert().
 * Executes once on adding new entity to the database.
 */
function editor_note_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'editor_note') {
    foreach ($items as $item) {
      editor_note_save($item['note'], $entity_type, $entity);
    }
  }
}

/**
 * Implements hook_field_update().
 * Executes every time entity gets updated.
 */
function editor_note_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'editor_note') {
    foreach ($items as $item) {
      editor_note_save($item['note'], $entity_type, $entity);
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function editor_note_field_formatter_info() {
  return array(
    'editor_note_field_formatter' => array(
      'label' => t('Editor Notes Table'),
      'field types' => array('editor_note'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function editor_note_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  if ($display['type'] == 'editor_note_field_formatter') {
    foreach ($items as $delta => $item) {
      $element[$delta] = array(
        '#markup' => $item['note'],
      );
    }
  }

  return $element;
}

/**
 * Implements hook_theme_registry_alter().
 */
function editor_note_theme_registry_alter(&$theme_registry) {
  if (isset($theme_registry['field_multiple_value_form'])) {
    $theme_registry['field_multiple_value_form']['type'] = 'module';
    $theme_registry['field_multiple_value_form']['theme path'] = drupal_get_path('module', ' notes_field');
    $theme_registry['field_multiple_value_form']['function'] =  'editor_note_theme_field_multiple_value_form';
  }
}

/**
 * Overrides multiple-value form widget for 'notes' field widget form.
 * @see theme_field_multiple_value_form()
 *
 * @param $variables
 *
 * @return array
 */
function editor_note_theme_field_multiple_value_form($variables) {
  $element = $variables['element'];
  $field_info = field_info_field($variables['element']['#field_name']);
  if ($field_info['type'] == 'editor_note') {
    // Custom function for 'notes' field widget form, field of other types have default functionality.
    // 'Notes' cardinality is always > 1 because 'notes' field makes sense only when at least 2 editors work on material.
    $output = editor_note_theme_widget_form($variables, $element);
  }
  else {
    // Otherwise use default theme function.
    $output = theme_field_multiple_value_form($variables);
  }
  return $output;
}

/**
 * Custom widget form for 'notes' field.
 *
 * @param $variables
 * @param $element
 *
 * @return string
 */
function editor_note_theme_widget_form($variables, $element) {
  $field_info = field_info_field($element['#field_name']);

  $add_note_field = $element[0];
  if (isset($add_note_field['_weight'])) {
    // Hide $items['_weight'] from display.
    $add_note_field['_weight']['#attributes']['class'][] = 'element-invisible';
  }
  $required = $element['#required'] ? ' ' . theme('form_required_marker', $variables) : '';
  if ($required) {
    // Add required mark to the title of 'Add Note' field.
    $add_note_field['note']['#title'] .= $required;
  }
  $notes = editor_note_get_notes(
    $element[0]['#entity_type'],
    $element[0]['#entity'],
    $field_info['settings']['limit'],
    $field_info['settings']['pager'],
    $field_info['settings']['order']
  );
  $formatted_notes = editor_note_get_formatted_notes($variables, $field_info, $notes);
  // @todo modify to save button so that it saves note via ajax, adds it as the next row and makes textarea blank.
  // @todo if cardinality setting present ensure that button doesn't show up.
  $add_note_button = array(
    '#type' => 'submit',
    '#name' => $element['#field_name'] . '_save_note',
    '#value' => t('Add Note'),
  );

  $output = array();

  if ($field_info['settings']['display'] == 0) {
    $output[] = $formatted_notes;
    $output[] = drupal_render($add_note_field);
    $output[] = drupal_render($add_note_button);
  }
  else {
    $output[] = drupal_render($add_note_field);
    $output[] = drupal_render($add_note_button);
    $output[] = $formatted_notes;
  }

  return '<div class="form-item">' . implode('', $output) . '</div>';
}

/**
 * Saves Editor Note.
 *
 * @param $note
 * @param $entity_type
 * @param $entity
 * @param null $uid
 * @param null $created
 * @param null $changed
 */
function editor_note_save($note, $entity_type, $entity, $uid = NULL, $created = NULL, $changed = NULL) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!isset($revision_id)) {
    $revision_id = $entity_id;
  }
  if (!isset($uid)) {
    global $user;
    $uid = $user->uid;
  }
  $editor_note = entity_create(
    'editor_note', array(
      'note' => $note,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'revision_id' => $revision_id,
      'uid' => (int) $uid,
      'created' => isset($created) ? $created : REQUEST_TIME,
      'changed' => isset($changed) ? $changed : REQUEST_TIME,
    )
  );
  entity_save('editor_note', $editor_note);
}

/**
 * Loads single Editor Note based on certain conditions.
 *
 * @param $note_id
 * @param array $conditions
 * @param bool $reset
 *
 * @return mixed
 */
function editor_note_load($note_id, $conditions = array(), $reset = FALSE) {
  return entity_load('editor_note', array($note_id), $conditions, $reset);
}

/**
 * Loads multiple Editor Notes based on certain conditions.
 *
 * @param $note_ids
 * @param array $conditions
 * @param bool $reset
 *
 * @return mixed
 */
function editor_note_load_multiple($note_ids, $conditions = array(), $reset = FALSE) {
  return entity_load('editor_note', $note_ids, $conditions, $reset);
}

/**
 * Deletes single Editor Notes.
 *
 * @param $note_id
 */
function editor_note_delete($note_id) {
  entity_delete('editor_note', $note_id);
}

/**
 * Deletes multiple Editor Notes.
 *
 * @param $note_ids
 */
function editor_note_delete_multiple($note_ids) {
  entity_delete_multiple('editor_note', $note_ids);
}

/**
 * Returns array of notes per entity revision.
 *
 * @param $entity_type
 * @param $entity
 *
 * @return array
 */
function editor_note_get_notes($entity_type, $entity, $limit = 10, $pager = TRUE, $order = 'DESC') {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

  $query = db_select('editor_note', 'en');

  if ($limit > 0) {
    if ($pager) {
      $query = $query->extend('PagerDefault');
      $query->limit($limit);
    }
    else {
      $query->range(0, $limit);
    }
  }

  $query->fields('en', array('id', 'note', 'entity_type', 'bundle', 'entity_id', 'revision_id', 'uid', 'created', 'changed'))
    ->condition('en.entity_type', $entity_type, '=')
    ->condition('en.entity_id', $entity_id, '=')
    ->condition('en.bundle', $bundle, '=')
    ->condition('en.revision_id', $revision_id, '=')
    ->orderBy('en.created', $order);

  $notes = $query->execute()->fetchAllAssoc('id');

  return $notes;
}

/**
 * Returns formatted notes table.
 *
 * @param $notes
 *
 * @return string
 */
function editor_note_get_formatted_notes($variables, $field_info, $notes) {
  global $user;

  $element = $variables['element'];
  $table_id = drupal_html_id($element['#field_name'] . '_values');

  $header = array(
    array(
      'data' => '<label>' . t('!title', array('!title' => $element['#title'])) . '</label>',
      'class' => array('field-label'),
    ),
    array(
      'data' => t('Author'),
      'class' => array('field-author'),
    ),
    array(
      'data' => t('Created'),
      'class' => array('field-created'),
    ),
    array(
      'data' => t('Changed'),
      'class' => array('field-changed'),
    ),
    array(
      'data' => t('Operations'),
      'class' => array('field-operations'),
    ),
  );

  $rows = array();
  $counter = 0;

  // @todo check if element can be required and validation should stop from saving empty field.
  // @todo check if user may access user profiles

  foreach ($notes as $note_id => $item) {
    $operations = ($user->uid != $item->uid && $user->uid != 1) ? '' : theme('item_list',
      array(
        'items' => array(
          l(t('edit'), '', array('attributes' => array('class' => array('edit-note'), 'data-delta' => $note_id))),
          l(t('remove'), '', array('attributes' => array('class' => array('remove-note'), 'data-delta' => $note_id))),
        )
      )
    );
    $rows[$counter] = array(
      'data' => array(
        'note' => array(
          'data' => $item->note,
          'class' => array('note'),
        ),
        'author' => array(
          'data' => l(format_username(user_load($item->uid)), 'user/' . $item->uid),
          'class' => array('author'),
        ),
        'changed' => array(
          'data' => format_date($item->changed, 'short'),
          'class' => array('changed'),
        ),
        'created' => array(
          'data' => format_date($item->created, 'short'),
          'class' => array('created'),
        ),
        'operations' => array(
          'data' => $operations,
          'class' => array('operations'),
        ),
      ),
      'class' => array('note-' . $note_id),
    );
    $counter++;
  }

  $notes_table = theme(
    'table',
    array(
      'header' => $header,
      'rows' => $rows,
      'attributes' => array(
        'id' => $table_id,
        'class' => array('field-notes-table')
      )
    )
  );

  $formatted_notes = $field_info['settings']['pager_below'] == 1 ?
    ($notes_table . theme('pager')) : (theme('pager') . $notes_table);

  return $formatted_notes;
}

/**
 * Form element validation handler for integer elements that must be positive or 0.
 *
 * @param $element
 * @param $form_state
 */
function editor_note_validate_integer_positive_or_zero($element, &$form_state) {
  $value = $element['#value'];
  if ($value !== '' && (!is_numeric($value) || intval($value) != $value || $value < 0)) {
    form_error($element, t('%name must be a positive integer or 0.', array('%name' => $element['#title'])));
  }
}
